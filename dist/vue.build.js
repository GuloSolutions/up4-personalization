/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.5.13\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Vue = factory();\n})(this, function () {\n  'use strict';\n\n  /*  */\n\n  var emptyObject = Object.freeze({});\n\n  // these helpers produces better vm code in JS engines due to their\n  // explicitness and function inlining\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n\n  /**\n   * Check if value is primitive\n   */\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' || typeof value === 'boolean';\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n  }\n\n  /**\n   * Get the raw type string of a value e.g. [object Object]\n   */\n  var _toString = Object.prototype.toString;\n\n  function toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n\n  /**\n   * Check if val is a valid array index.\n   */\n  function isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function toString(val) {\n    return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);\n  }\n\n  /**\n   * Convert a input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Check if a attribute is a reserved attribute.\n   */\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n  /**\n   * Remove an item from an array\n   */\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Check whether the object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n  });\n\n  /**\n   * Simple bind, faster than native\n   */\n  function bind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n    // record original fn length\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret;\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n    return to;\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject(arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n   */\n  function noop(a, b, c) {}\n\n  /**\n   * Always return false.\n   */\n  var no = function (a, b, c) {\n    return false;\n  };\n\n  /**\n   * Return same value\n   */\n  var identity = function (_) {\n    return _;\n  };\n\n  /**\n   * Generate a static keys string from compiler modules.\n   */\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n  function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i]);\n          });\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key]);\n          });\n        } else {\n          /* istanbul ignore next */\n          return false;\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Ensure a function is called only once.\n   */\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];\n\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n\n  /*  */\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n\n  /**\n   * Define a property.\n   */\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = /[^\\w.$]/;\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n        obj = obj[segments[i]];\n      }\n      return obj;\n    };\n  }\n\n  /*  */\n\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n  // Firefox has a \"watch\" function on Object.prototype...\n  var nativeWatch = {}.watch;\n\n  var supportsPassive = false;\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  }\n\n  // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n  var _isServer;\n  var isServerRendering = function () {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n    return _isServer;\n  };\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  /* istanbul ignore next */\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */ // $flow-disable-line\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n\n  /*  */\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = noop; // work around flow check\n  var formatComponentName = noop;\n\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n    var classify = function (str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function (msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function (msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function (vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function (str, n) {\n      var res = '';\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n        if (n > 1) {\n          str += str;\n        }\n        n >>= 1;\n      }\n      return res;\n    };\n\n    generateComponentTrace = function (vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n\n  /*  */\n\n  var uid = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  // the current target watcher being evaluated.\n  // this is globally unique because there could be only one\n  // watcher being evaluated at any time.\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(_target) {\n    if (Dep.target) {\n      targetStack.push(Dep.target);\n    }\n    Dep.target = _target;\n  }\n\n  function popTarget() {\n    Dep.target = targetStack.pop();\n  }\n\n  /*  */\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = { child: { configurable: true } };\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function (text) {\n    if (text === void 0) text = '';\n\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  }\n\n  // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n  function cloneVNode(vnode, deep) {\n    var componentOptions = vnode.componentOptions;\n    var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.isCloned = true;\n    if (deep) {\n      if (vnode.children) {\n        cloned.children = cloneVNodes(vnode.children, true);\n      }\n      if (componentOptions && componentOptions.children) {\n        componentOptions.children = cloneVNodes(componentOptions.children, true);\n      }\n    }\n    return cloned;\n  }\n\n  function cloneVNodes(vnodes, deep) {\n    var len = vnodes.length;\n    var res = new Array(len);\n    for (var i = 0; i < len; i++) {\n      res[i] = cloneVNode(vnodes[i], deep);\n    }\n    return res;\n  }\n\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n      while (len--) args[len] = arguments[len];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n      if (inserted) {\n        ob.observeArray(inserted);\n      }\n      // notify change\n      ob.dep.notify();\n      return result;\n    });\n  });\n\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * By default, when a reactive property is set, the new value is\n   * also converted to become reactive. However when passing down props,\n   * we don't want to force conversion because the value may be a nested value\n   * under a frozen data structure. Converting it would defeat the optimization.\n   */\n  var observerState = {\n    shouldConvert: true\n  };\n\n  /**\n   * Observer class that are attached to each observed\n   * object. Once attached, the observer converts target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatches updates.\n   */\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n    if (Array.isArray(value)) {\n      var augment = hasProto ? protoAugment : copyAugment;\n      augment(value, arrayMethods, arrayKeys);\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i], obj[keys[i]]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   */\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  // helpers\n\n  /**\n   * Augment an target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment(target, src, keys) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment an target Object or Array by defining\n   * hidden properties.\n   */\n  /* istanbul ignore next */\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe(value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return;\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n    return ob;\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return;\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n        if (\"development\" !== 'production' && customSetter) {\n          customSetter();\n        }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set(target, key, val) {\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val;\n    }\n    var ob = target.__ob__;\n    if (target._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n    defineReactive(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del(target, key) {\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n    var ob = target.__ob__;\n    if (target._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n    if (!hasOwn(target, key)) {\n      return;\n    }\n    delete target[key];\n    if (!ob) {\n      return;\n    }\n    ob.dep.notify();\n  }\n\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n      return defaultStrat(parent, child);\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n    var key, toVal, fromVal;\n    var keys = Object.keys(from);\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to;\n  }\n\n  /**\n   * Data\n   */\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n      if (!parentVal) {\n        return childVal;\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n      };\n    } else {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        \"development\" !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\n        return parentVal;\n      }\n      return mergeDataOrFn(parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n\n  /**\n   * Hooks and props are merged as arrays.\n   */\n  function mergeHook(parentVal, childVal) {\n    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n    if (childVal) {\n      \"development\" !== 'production' && assertObjectType(key, childVal, vm);\n      return extend(res, childVal);\n    } else {\n      return res;\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n    {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n    return ret;\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    if (childVal) {\n      extend(ret, childVal);\n    }\n    return ret;\n  };\n  strats.provide = mergeDataOrFn;\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n\n  /**\n   * Validate component names\n   */\n  function checkComponents(options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName(name) {\n    if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n      warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps(options, vm) {\n    var props = options.props;\n    if (!props) {\n      return;\n    }\n    var res = {};\n    var i, val, name;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : { type: val };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize all injections into Object-based format\n   */\n  function normalizeInject(options, vm) {\n    var inject = options.inject;\n    if (!inject) {\n      return;\n    }\n    var normalized = options.inject = {};\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = { from: inject[i] };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n    }\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def = dirs[key];\n        if (typeof def === 'function') {\n          dirs[key] = { bind: def, update: def };\n        }\n      }\n    }\n  }\n\n  function assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n    var extendsFrom = child.extends;\n    if (extendsFrom) {\n      parent = mergeOptions(parent, extendsFrom, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n    var options = {};\n    var key;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    }\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (\"development\" !== 'production' && warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n    return res;\n  }\n\n  /*  */\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // handle boolean props\n    if (isType(Boolean, prop.type)) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n        value = true;\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldConvert = observerState.shouldConvert;\n      observerState.shouldConvert = true;\n      observe(value);\n      observerState.shouldConvert = prevShouldConvert;\n    }\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (\"development\" !== 'production' && isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n    if (value == null && !prop.required) {\n      return;\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n    if (!valid) {\n      warn(\"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ') + \", got \" + toRawType(value) + \".\", vm);\n      return;\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType(value, type) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value;\n      valid = t === expectedType.toLowerCase();\n      // for primitive wrapper objects\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType(fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : '';\n  }\n\n  function isType(type, fn) {\n    if (!Array.isArray(fn)) {\n      return getType(fn) === getType(type);\n    }\n    for (var i = 0, len = fn.length; i < len; i++) {\n      if (getType(fn[i]) === getType(type)) {\n        return true;\n      }\n    }\n    /* istanbul ignore next */\n    return false;\n  }\n\n  /*  */\n\n  function handleError(err, vm, info) {\n    if (vm) {\n      var cur = vm;\n      while (cur = cur.$parent) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) {\n                return;\n              }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  }\n\n  function globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info);\n      } catch (e) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n    logError(err, vm, info);\n  }\n\n  function logError(err, vm, info) {\n    {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /*  */\n  /* globals MessageChannel */\n\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // Here we have async deferring wrappers using both micro and macro tasks.\n  // In < 2.4 we used micro tasks everywhere, but there are some scenarios where\n  // micro tasks have too high a priority and fires in between supposedly\n  // sequential events (e.g. #4521, #6690) or even between bubbling of the same\n  // event (#6566). However, using macro tasks everywhere also has subtle problems\n  // when state is changed right before repaint (e.g. #6813, out-in transitions).\n  // Here we use micro task by default, but expose a way to force macro task when\n  // needed (e.g. in event handlers attached by v-on).\n  var microTimerFunc;\n  var macroTimerFunc;\n  var useMacroTask = false;\n\n  // Determine (macro) Task defer implementation.\n  // Technically setImmediate should be the ideal choice, but it's only available\n  // in IE. The only polyfill that consistently queues the callback after all DOM\n  // events triggered in the same loop is by using MessageChannel.\n  /* istanbul ignore if */\n  if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    macroTimerFunc = function () {\n      setImmediate(flushCallbacks);\n    };\n  } else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||\n  // PhantomJS\n  MessageChannel.toString() === '[object MessageChannelConstructor]')) {\n    var channel = new MessageChannel();\n    var port = channel.port2;\n    channel.port1.onmessage = flushCallbacks;\n    macroTimerFunc = function () {\n      port.postMessage(1);\n    };\n  } else {\n    /* istanbul ignore next */\n    macroTimerFunc = function () {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  // Determine MicroTask defer implementation.\n  /* istanbul ignore next, $flow-disable-line */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    microTimerFunc = function () {\n      p.then(flushCallbacks);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n  } else {\n    // fallback to macro\n    microTimerFunc = macroTimerFunc;\n  }\n\n  /**\n   * Wrap a function so that if any code inside triggers state change,\n   * the changes are queued using a Task instead of a MicroTask.\n   */\n  function withMacroTask(fn) {\n    return fn._withTask || (fn._withTask = function () {\n      useMacroTask = true;\n      var res = fn.apply(null, arguments);\n      useMacroTask = false;\n      return res;\n    });\n  }\n\n  function nextTick(cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      if (useMacroTask) {\n        macroTimerFunc();\n      } else {\n        microTimerFunc();\n      }\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  }\n\n  /*  */\n\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function (tag) {\n        return perf.mark(tag);\n      };\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        perf.clearMeasures(name);\n      };\n    }\n  }\n\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function (target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n        if (!has && !isAllowed) {\n          warnNonPresent(target, key);\n        }\n        return has || !isAllowed;\n      }\n    };\n\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          warnNonPresent(target, key);\n        }\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n\n  /*  */\n\n  var seenObjects = new _Set();\n\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n  function traverse(val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n    if (!isA && !isObject(val) || Object.isFrozen(val)) {\n      return;\n    }\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return;\n      }\n      seen.add(depId);\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n\n  /*  */\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns) {\n    function invoker() {\n      var arguments$1 = arguments;\n\n      var fns = invoker.fns;\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n        for (var i = 0; i < cloned.length; i++) {\n          cloned[i].apply(null, arguments$1);\n        }\n      } else {\n        // return handler return value for single handlers\n        return fns.apply(null, arguments);\n      }\n    }\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, vm) {\n    var name, def, cur, old, event;\n    for (name in on) {\n      def = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      /* istanbul ignore if */\n      if (isUndef(cur)) {\n        \"development\" !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur);\n        }\n        add(event.name, cur, event.once, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n\n  /*  */\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments);\n      // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n\n  /*  */\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n      return;\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /*  */\n\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n    return children;\n  }\n\n  // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n      lastIndex = res.length - 1;\n      last = res[lastIndex];\n      //  nested\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i);\n          // merge adjacent text nodes\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + c[0].text);\n            c.shift();\n          }\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n      comp = comp.default;\n    }\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor, context) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (isDef(factory.contexts)) {\n      // already pending\n      factory.contexts.push(context);\n    } else {\n      var contexts = factory.contexts = [context];\n      var sync = true;\n\n      var forceRender = function () {\n        for (var i = 0, l = contexts.length; i < l; i++) {\n          contexts[i].$forceUpdate();\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor);\n        // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n        if (!sync) {\n          forceRender();\n        }\n      });\n\n      var reject = once(function (reason) {\n        \"development\" !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender();\n        }\n      });\n\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (typeof res.then === 'function') {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isDef(res.component) && typeof res.component.then === 'function') {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              setTimeout(function () {\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender();\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            setTimeout(function () {\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false;\n      // return in case resolved synchronously\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n\n  /*  */\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n\n  /*  */\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c;\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn, once) {\n    if (once) {\n      target.$once(event, fn);\n    } else {\n      target.$on(event, fn);\n    }\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n    target = undefined;\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n      var this$1 = this;\n\n      var vm = this;\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          this$1.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn);\n        // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var this$1 = this;\n\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      }\n      // array of events\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          this$1.$off(event[i], fn);\n        }\n        return vm;\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm;\n      }\n      if (!fn) {\n        vm._events[event] = null;\n        return vm;\n      }\n      if (fn) {\n        // specific handler\n        var cb;\n        var i$1 = cbs.length;\n        while (i$1--) {\n          cb = cbs[i$1];\n          if (cb === fn || cb.fn === fn) {\n            cbs.splice(i$1, 1);\n            break;\n          }\n        }\n      }\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          try {\n            cbs[i].apply(vm, args);\n          } catch (e) {\n            handleError(e, vm, \"event handler for \\\"\" + event + \"\\\"\");\n          }\n        }\n      }\n      return vm;\n    };\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n  function resolveSlots(children, context) {\n    var slots = {};\n    if (!children) {\n      return slots;\n    }\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data;\n      // remove slot attribute if the node is resolved as a Vue slot node\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      }\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n        var name = data.slot;\n        var slot = slots[name] || (slots[name] = []);\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    }\n    // ignore slots that contains only whitespace\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment && !node.asyncFactory || node.text === ' ';\n  }\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res) {\n    res = res || {};\n    for (var i = 0; i < fns.length; i++) {\n      if (Array.isArray(fns[i])) {\n        resolveScopedSlots(fns[i], res);\n      } else {\n        res[fns[i].key] = fns[i].fn;\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function initLifecycle(vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      if (vm._isMounted) {\n        callHook(vm, 'beforeUpdate');\n      }\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var prevActiveInstance = activeInstance;\n      activeInstance = vm;\n      vm._vnode = vnode;\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n        , vm.$options._parentElm, vm.$options._refElm);\n        // no need for the ref nodes after initial patch\n        // this prevents keeping a detached DOM tree in memory (#5851)\n        vm.$options._parentElm = vm.$options._refElm = null;\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      activeInstance = prevActiveInstance;\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      // invoke destroy hooks on current rendered tree\n      vm.__patch__(vm._vnode, null);\n      // fire destroyed hook\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n      // release circular reference (#6759)\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n\n    var updateComponent;\n    /* istanbul ignore if */\n    if (\"development\" !== 'production' && config.performance && mark) {\n      updateComponent = function () {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n\n        mark(startTag);\n        var vnode = vm._render();\n        mark(endTag);\n        measure(\"vue \" + name + \" render\", startTag, endTag);\n\n        mark(startTag);\n        vm._update(vnode, hydrating);\n        mark(endTag);\n        measure(\"vue \" + name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n      };\n    }\n\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);\n    hydrating = false;\n\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    }\n\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren\n    var hasChildren = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n    );\n\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    vm.$attrs = parentVnode.data && parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject;\n\n    // update props\n    if (propsData && vm.$options.props) {\n      observerState.shouldConvert = false;\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        props[key] = validateProp(key, vm.$options.props, propsData, vm);\n      }\n      observerState.shouldConvert = true;\n      // keep a copy of raw propsData\n      vm.$options.propsData = propsData;\n    }\n\n    // update listeners\n    if (listeners) {\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      updateComponentListeners(vm, listeners, oldListeners);\n    }\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n    if (!vm._inactive) {\n      vm._inactive = true;\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    var handlers = vm.$options[hook];\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        try {\n          handlers[i].call(vm);\n        } catch (e) {\n          handleError(e, vm, hook + \" hook\");\n        }\n      }\n    }\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n  }\n\n  /*  */\n\n  var MAX_UPDATE_COUNT = 100;\n\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue() {\n    flushing = true;\n    var watcher, id;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (\"development\" !== 'production' && has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    }\n\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n      if (vm._watcher === watcher && vm._isMounted) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true /* true */);\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  /*  */\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm;\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n    vm._watchers.push(this);\n    // options\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString();\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n      if (!this.getter) {\n        this.getter = function () {};\n        \"development\" !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n    this.value = this.lazy ? undefined : this.get();\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n    }\n    return value;\n  };\n\n  /**\n   * Add a dependency to this directive.\n   */\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var this$1 = this;\n\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this$1.deps[i];\n      if (!this$1.newDepIds.has(dep.id)) {\n        dep.removeSub(this$1);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n      if (value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  Watcher.prototype.depend = function depend() {\n    var this$1 = this;\n\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  Watcher.prototype.teardown = function teardown() {\n    var this$1 = this;\n\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this$1.deps[i].removeSub(this$1);\n      }\n      this.active = false;\n    }\n  };\n\n  /*  */\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true /* asRootData */);\n    }\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {};\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    observerState.shouldConvert = isRoot;\n    var loop = function (key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n      {\n        var hyphenatedKey = hyphenate(key);\n        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n          warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n        defineReactive(props, key, value, function () {\n          if (vm.$parent && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      }\n      // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) loop(key);\n    observerState.shouldConvert = true;\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      \"development\" !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n      if (props && hasOwn(props, key)) {\n        \"development\" !== 'production' && warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    }\n    // observe data\n    observe(data, true /* asRootData */);\n  }\n\n  function getData(data, vm) {\n    try {\n      return data.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    }\n  }\n\n  var computedWatcherOptions = { lazy: true };\n\n  function initComputed(vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null);\n    // computed properties are just getters during SSR\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n      if (\"development\" !== 'production' && getter == null) {\n        warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n      }\n\n      // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n      sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n    }\n    if (\"development\" !== 'production' && sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n      };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value;\n      }\n    };\n  }\n\n  function initMethods(vm, methods) {\n    var props = vm.$options.props;\n    for (var key in methods) {\n      {\n        if (methods[key] == null) {\n          warn(\"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n        if (key in vm && isReserved(key)) {\n          warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n        }\n      }\n      vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch(vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, keyOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    return vm.$watch(keyOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () {\n      return this._data;\n    };\n    var propsDef = {};\n    propsDef.get = function () {\n      return this._props;\n    };\n    {\n      dataDef.set = function (newData) {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        cb.call(vm, watcher.value);\n      }\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n\n  /*  */\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n      observerState.shouldConvert = false;\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      observerState.shouldConvert = true;\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {\n        /* istanbul ignore next */\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable;\n      }) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var provideKey = inject[key].from;\n        var source = vm;\n        while (source) {\n          if (source._provided && provideKey in source._provided) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n          source = source.$parent;\n        }\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n          } else {\n            warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n          }\n        }\n      }\n      return result;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    if (isDef(ret)) {\n      ret._isVList = true;\n    }\n    return ret;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n  function renderSlot(name, fallback, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n      if (bindObject) {\n        if (\"development\" !== 'production' && !isObject(bindObject)) {\n          warn('slot v-bind without argument expects an Object', this);\n        }\n        props = extend(extend({}, bindObject), props);\n      }\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      var slotNodes = this.$slots[name];\n      // warn duplicate slot usage\n      if (slotNodes) {\n        if (\"development\" !== 'production' && slotNodes._rendered) {\n          warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n        }\n        slotNodes._rendered = true;\n      }\n      nodes = slotNodes || fallback;\n    }\n\n    var target = props && props.slot;\n    if (target) {\n      return this.$createElement('template', { slot: target }, nodes);\n    } else {\n      return nodes;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n  function checkKeyCodes(eventKeyCode, key, builtInAlias, eventKeyName) {\n    var keyCodes = config.keyCodes[key] || builtInAlias;\n    if (keyCodes) {\n      if (Array.isArray(keyCodes)) {\n        return keyCodes.indexOf(eventKeyCode) === -1;\n      } else {\n        return keyCodes !== eventKeyCode;\n      }\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        \"development\" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        var hash;\n        var loop = function (key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n          if (!(key in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) loop(key);\n      }\n    }\n    return data;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n  function renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree by doing a shallow clone.\n    if (tree && !isInFor) {\n      return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  /*  */\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        \"development\" !== 'production' && warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n    return data;\n  }\n\n  /*  */\n\n  function installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n  }\n\n  /*  */\n\n  function FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var options = Ctor.options;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = function () {\n      return resolveSlots(children, parent);\n    };\n\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var contextVm = Object.create(parent);\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n\n    // support for compiled functional template\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options;\n      // pre-resolve slots for renderSlot()\n      this.$slots = this.slots();\n      this.$scopedSlots = data.scopedSlots || emptyObject;\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n        if (vnode) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n        return vnode;\n      };\n    } else {\n      this._c = function (a, b, c, d) {\n        return createElement(contextVm, a, b, c, d, needNormalization);\n      };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      vnode.fnContext = contextVm;\n      vnode.fnOptions = options;\n      if (data.slot) {\n        (vnode.data || (vnode.data = {})).slot = data.slot;\n      }\n    }\n\n    return vnode;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n\n  /*  */\n\n  // Register the component hook to weex native render engine.\n  // The hook will be triggered by native, not javascript.\n\n\n  // Updates the state of the component to weex native render engine.\n\n  /*  */\n\n  // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n\n  // listening on native callback\n\n  /*  */\n\n  /*  */\n\n  // hooks to be invoked on component VNodes during patch\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating, parentElm, refElm) {\n      if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      } else if (vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      }\n    },\n\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    },\n\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    }\n  };\n\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base;\n\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    }\n\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    }\n\n    // async component\n    var asyncFactory;\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {};\n\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    }\n\n    // extract props\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n    // functional component\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    }\n\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n\n      // work around flow\n      var slot = data.slot;\n      data = {};\n      if (slot) {\n        data.slot = slot;\n      }\n    }\n\n    // merge component management hooks onto the placeholder node\n    mergeHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\n\n    // Weex specific: invoke recycle-list optimized @render function for\n    // extracting cell-slot template.\n    // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n    /* istanbul ignore if */\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm, refElm) {\n    var options = {\n      _isComponent: true,\n      parent: parent,\n      _parentVnode: vnode,\n      _parentElm: parentElm || null,\n      _refElm: refElm || null\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options);\n  }\n\n  function mergeHooks(data) {\n    if (!data.hook) {\n      data.hook = {};\n    }\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var fromParent = data.hook[key];\n      var ours = componentVNodeHooks[key];\n      data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n    }\n  }\n\n  function mergeHook$1(one, two) {\n    return function (a, b, c, d) {\n      one(a, b, c, d);\n      two(a, b, c, d);\n    };\n  }\n\n  // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    if (isDef(on[event])) {\n      on[event] = [data.model.callback].concat(on[event]);\n    } else {\n      on[event] = data.model.callback;\n    }\n  }\n\n  /*  */\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2;\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      \"development\" !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    }\n    // warn against non-primitive key\n    if (\"development\" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      {\n        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n      }\n    }\n    // support single function children as default scoped slot\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = { default: children[0] };\n      children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n    if (isDef(vnode)) {\n      if (ns) {\n        applyNS(vnode, ns);\n      }\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    };\n\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n\n    /* istanbul ignore else */\n    {\n      defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  function renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (vm._isMounted) {\n        // if the parent didn't update, the slot nodes will be the ones from\n        // last render. They need to be cloned to ensure \"freshness\" for this render.\n        for (var key in vm.$slots) {\n          var slot = vm.$slots[key];\n          // _rendered is a flag added by renderSlot, but may not be present\n          // if the slot is passed from manually written render functions\n          if (slot._rendered || slot[0] && slot[0].elm) {\n            vm.$slots[key] = cloneVNodes(slot, true /* deep */);\n          }\n        }\n      }\n\n      vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;\n\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode;\n      try {\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\");\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        {\n          if (vm.$options.renderError) {\n            try {\n              vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n            } catch (e) {\n              handleError(e, vm, \"renderError\");\n              vnode = vm._vnode;\n            }\n          } else {\n            vnode = vm._vnode;\n          }\n        }\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (\"development\" !== 'production' && Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n        vnode = createEmptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n  }\n\n  /*  */\n\n  var uid$1 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid$1++;\n\n      var startTag, endTag;\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && config.performance && mark) {\n        startTag = \"vue-perf-start:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      }\n\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n      {\n        initProxy(vm);\n      }\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n      callHook(vm, 'created');\n\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options);\n    // doing this because it's faster than dynamic enumeration.\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    opts._parentElm = options._parentElm;\n    opts._refElm = options._refElm;\n\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions;\n        // check if there are any late-modified/attached options (#4976)\n        var modifiedOptions = resolveModifiedOptions(Ctor);\n        // update base extend options\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var extended = Ctor.extendOptions;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n        modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n      }\n    }\n    return modified;\n  }\n\n  function dedupe(latest, extended, sealed) {\n    // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n    // between merges\n    if (Array.isArray(latest)) {\n      var res = [];\n      sealed = Array.isArray(sealed) ? sealed : [sealed];\n      extended = Array.isArray(extended) ? extended : [extended];\n      for (var i = 0; i < latest.length; i++) {\n        // push original options and not sealed options to exclude duplicated options\n        if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n          res.push(latest[i]);\n        }\n      }\n      return res;\n    } else {\n      return latest;\n    }\n  }\n\n  function Vue$3(options) {\n    if (\"development\" !== 'production' && !(this instanceof Vue$3)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue$3);\n  stateMixin(Vue$3);\n  eventsMixin(Vue$3);\n  lifecycleMixin(Vue$3);\n  renderMixin(Vue$3);\n\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      }\n\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n\n  /*  */\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n\n  /*  */\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n      if (\"development\" !== 'production' && name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super;\n\n      // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      }\n\n      // allow further extension/mixin/plugin usage\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use;\n\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options);\n\n      // cache constructor\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n\n  /*  */\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (\"development\" !== 'production' && type === 'component') {\n            validateComponentName(id);\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n\n  /*  */\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n    return false;\n  }\n\n  function pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n    for (var key in cache) {\n      var cachedNode = cache[key];\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(cache, key, keys, current) {\n    var cached$$1 = cache[key];\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n\n    created: function created() {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n\n    destroyed: function destroyed() {\n      var this$1 = this;\n\n      for (var key in this$1.cache) {\n        pruneCacheEntry(this$1.cache, key, this$1.keys);\n      }\n    },\n\n    watch: {\n      include: function include(val) {\n        pruneCache(this, function (name) {\n          return matches(val, name);\n        });\n      },\n      exclude: function exclude(val) {\n        pruneCache(this, function (name) {\n          return !matches(val, name);\n        });\n      }\n    },\n\n    render: function render() {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n        if (\n        // not included\n        include && (!name || !matches(include, name)) ||\n        // excluded\n        exclude && name && matches(exclude, name)) {\n          return vnode;\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance;\n          // make current key freshest\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key);\n          // prune oldest entry\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n      return vnode || slot && slot[0];\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n\n  /*  */\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () {\n      return config;\n    };\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive\n    };\n\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue$3);\n\n  Object.defineProperty(Vue$3.prototype, '$isServer', {\n    get: isServerRendering\n  });\n\n  Object.defineProperty(Vue$3.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  });\n\n  Vue$3.version = '2.5.13';\n\n  /*  */\n\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n  var isReservedAttr = makeMap('style,class');\n\n  // attributes that should be using props for binding\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n  var mustUseProp = function (tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function (val) {\n    return val == null || val === false;\n  };\n\n  /*  */\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return renderClass(data.staticClass, data.class);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n        res += stringified;\n      }\n    }\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n        res += key;\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function (tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n    if (isReservedTag(tag)) {\n      return false;\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n      if (!selected) {\n        \"development\" !== 'production' && warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n      return selected;\n    } else {\n      return el;\n    }\n  }\n\n  /*  */\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n      return elm;\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setAttribute(node, key, val) {\n    node.setAttribute(key, val);\n  }\n\n  var nodeOps = Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setAttribute: setAttribute\n  });\n\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!key) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n  var emptyNode = new VNode('', {}, []);\n\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n  }\n\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove() {\n        if (--remove.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n      remove.listeners = listeners;\n      return remove;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el);\n      // element may have already been removed due to v-html / v-text\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1(vnode, inVPre) {\n      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n      })) && config.isUnknownElement(vnode.tag);\n    }\n\n    var creatingElmInVPre = 0;\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n      vnode.isRootInsert = !nested; // for transition enter check\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n\n        /* istanbul ignore if */\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (\"development\" !== 'production' && data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false /* hydrating */, parentElm, refElm);\n        }\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n      vnode.elm = vnode.componentInstance.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode);\n        // make sure to invoke the insert hook\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i;\n      // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n      var innerNode = vnode;\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      }\n      // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (ref$$1.parentNode === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope(vnode) {\n      var i;\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      } else {\n        var ancestor = vnode;\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setAttribute(vnode.elm, i, '');\n          }\n          ancestor = ancestor.parent;\n        }\n      }\n      // for slot content they should also get the scopeId from the host instance.\n      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            }\n          }\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys(children) {\n      var seenKeys = {};\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld(node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n        if (isDef(c) && sameVnode(node, c)) {\n          return i;\n        }\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n        return;\n      }\n\n      // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || data && data.pre;\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      }\n      // assert node match\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false;\n        }\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true /* hydrating */);\n        }\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (\"development\" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n                return false;\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break;\n                }\n                childNode = childNode.nextSibling;\n              }\n              // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (\"development\" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n                return false;\n              }\n            }\n          }\n        }\n        if (isDef(data)) {\n          var fullInvoke = false;\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n\n          // replacing existing element\n          var oldElm = oldVnode.elm;\n          var parentElm$1 = nodeOps.parentNode(oldElm);\n\n          // create new node\n          createElm(vnode, insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n          // update parent placeholder node element, recursively\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n              ancestor.elm = vnode.elm;\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                }\n                // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n                var insert = ancestor.data.hook.insert;\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n              ancestor = ancestor.parent;\n            }\n          }\n\n          // destroy old node\n          if (isDef(parentElm$1)) {\n            removeVnodes(parentElm$1, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n\n  /*  */\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n\n    var key, oldDir, dir;\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        callHook$1(dir, 'update', vnode, oldVnode);\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function () {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n    if (!dirs) {\n      // $flow-disable-line\n      return res;\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value) {\n    if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // #7138: IE10 & 11 fires input event when setting placeholder on\n        // <textarea>... block the first input event and remove the blocker\n        // immediately.\n        /* istanbul ignore if */\n        if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {\n          var blocker = function (e) {\n            e.stopImmediatePropagation();\n            el.removeEventListener('input', blocker);\n          };\n          el.addEventListener('input', blocker);\n          // $flow-disable-line\n          el.__ieph = true; /* IE placeholder patched */\n        }\n        el.setAttribute(key, value);\n      }\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n\n  /*  */\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;break; // \"\n          case 0x27:\n            inSingle = true;break; // '\n          case 0x60:\n            inTemplateString = true;break; // `\n          case 0x28:\n            paren++;break; // (\n          case 0x29:\n            paren--;break; // )\n          case 0x5B:\n            square++;break; // [\n          case 0x5D:\n            square--;break; // ]\n          case 0x7B:\n            curly++;break; // {\n          case 0x7D:\n            curly--;break; // }\n        }\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0;\n          // find first non-whitespace prev char\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n            if (p !== ' ') {\n              break;\n            }\n          }\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args;\n    }\n  }\n\n  /*  */\n\n  function baseWarn(msg) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value) {\n    (el.props || (el.props = [])).push({ name: name, value: value });\n    el.plain = false;\n  }\n\n  function addAttr(el, name, value) {\n    (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n    el.plain = false;\n  }\n\n  // add a raw attr (use this in preTransforms)\n  function addRawAttr(el, name, value) {\n    el.attrsMap[name] = value;\n    el.attrsList.push({ name: name, value: value });\n  }\n\n  function addDirective(el, name, rawName, value, arg, modifiers) {\n    (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n    el.plain = false;\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (\"development\" !== 'production' && warn && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n    }\n\n    // check capture modifier\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = '!' + name; // mark the event as captured\n    }\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = '~' + name; // mark the event as once\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = '&' + name; // mark the event as passive\n    }\n\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (name === 'click') {\n      if (modifiers.right) {\n        name = 'contextmenu';\n        delete modifiers.right;\n      } else if (modifiers.middle) {\n        name = 'mouseup';\n      }\n    }\n\n    var events;\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = { value: value };\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  }\n\n  // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n  function getAndRemoveAttr(el, name, removeFromMap) {\n    var val;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n    return val;\n  }\n\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n    var assignment = genAssignmentCode(value, valueExpression);\n\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: \"\\\"\" + value + \"\\\"\",\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n  function genAssignmentCode(value, assignment) {\n    var res = parseModel(value);\n    if (res.key === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n    }\n  }\n\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n  var len;\n  var str;\n  var chr;\n  var index$1;\n  var expressionPos;\n  var expressionEndPos;\n\n  function parseModel(val) {\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        };\n      } else {\n        return {\n          exp: val,\n          key: null\n        };\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n    while (!eof()) {\n      chr = next();\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n    while (!eof()) {\n      chr = next();\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n\n  /*  */\n\n  var warn$1;\n\n  // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n    }\n\n    // ensure runtime directive metadata\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat([$$v]))}\" + \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type;\n\n    // warn if v-bind:value conflicts with v-model\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      if (value$1) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally');\n      }\n    }\n\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n    var valueExpression = '$event.target.value';\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n\n  /*  */\n\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n  function normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler(handler, event, capture) {\n    var _target = target$1; // save current target element in closure\n    return function onceHandler() {\n      var res = handler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    };\n  }\n\n  function add$1(event, handler, once$$1, capture, passive) {\n    handler = withMacroTask(handler);\n    if (once$$1) {\n      handler = createOnceHandler(handler, event, capture);\n    }\n    target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n  }\n\n  function remove$2(event, handler, capture, _target) {\n    (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return;\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n\n  /*  */\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (isUndef(props[key])) {\n        elm[key] = '';\n      }\n    }\n    for (key in props) {\n      cur = props[key];\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n        if (cur === oldProps[key]) {\n          continue;\n        }\n        // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = isUndef(cur) ? '' : String(cur);\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else {\n        elm[key] = cur;\n      }\n    }\n  }\n\n  // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, checkVal) {\n    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n  }\n\n  function isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try {\n      notInFocus = document.activeElement !== elm;\n    } catch (e) {}\n    return notInFocus && elm.value !== checkVal;\n  }\n\n  function isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n      if (modifiers.lazy) {\n        // inputs with lazy should only be updated when not in focus\n        return false;\n      }\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal);\n      }\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim();\n      }\n    }\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  });\n\n  // merge static and dynamic style data on the same vnode\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  }\n\n  // normalize possible array / string values into Object\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n    return bindingStyle;\n  }\n\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n  var setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n    for (name in newStyle) {\n      cur = newStyle[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n\n  /*  */\n\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      cur = cur.trim();\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n\n  /*  */\n\n  function resolveTransition(def) {\n    if (!def) {\n      return;\n    }\n    /* istanbul ignore else */\n    if (typeof def === 'object') {\n      var res = {};\n      if (def.css !== false) {\n        extend(res, autoCssTransition(def.name || 'v'));\n      }\n      extend(res, def);\n      return res;\n    } else if (typeof def === 'string') {\n      return autoCssTransition(def);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  // binding to window is necessary to make hot reload work in IE in strict mode\n  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {\n    return fn();\n  };\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n    if (!type) {\n      return cb();\n    }\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function () {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function (e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = styles[animationProp + 'Delay'].split(', ');\n    var animationDurations = styles[animationProp + 'Duration'].split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  }\n\n  function toMs(s) {\n    return Number(s.slice(0, -1)) * 1000;\n  }\n\n  /*  */\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return;\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n      transitionNode = transitionNode.parent;\n      context = transitionNode.context;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (\"development\" !== 'production' && explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        addTransitionClass(el, toClass);\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm();\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (\"development\" !== 'production' && isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      }\n      // record leaving element\n      if (!vnode.data.show) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          addTransitionClass(el, leaveToClass);\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled && !userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  // only used in dev mode\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n\n  /*  */\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted(el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n        if (!binding.modifiers.lazy) {\n          // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n          el.addEventListener('change', onCompositionEnd);\n          if (!isAndroid) {\n            el.addEventListener('compositionstart', onCompositionStart);\n            el.addEventListener('compositionend', onCompositionEnd);\n          }\n          /* istanbul ignore if */\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n        if (curOptions.some(function (o, i) {\n          return !looseEqual(o, prevOptions[i]);\n        })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple ? binding.value.some(function (v) {\n            return hasNoMatchingOption(v, curOptions);\n          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n      \"development\" !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n          return;\n        }\n      }\n    }\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    return options.every(function (o) {\n      return !looseEqual(o, value);\n    });\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  /*  */\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n\n      /* istanbul ignore if */\n      if (value === oldValue) {\n        return;\n      }\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      if (transition$$1) {\n        vnode.data.show = true;\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n\n  /*  */\n\n  // Provides transition support for a single element/component.\n  // supports transition mode (out-in / in-out)\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n\n    render: function render(h) {\n      var this$1 = this;\n\n      var children = this.$slots.default;\n      if (!children) {\n        return;\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(function (c) {\n        return c.tag || isAsyncPlaceholder(c);\n      });\n      /* istanbul ignore if */\n      if (!children.length) {\n        return;\n      }\n\n      // warn multiple elements\n      if (\"development\" !== 'production' && children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (\"development\" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      }\n\n      // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      // mark v-show\n      // so that the transition module can hand over the control to the directive\n      if (child.data.directives && child.data.directives.some(function (d) {\n        return d.name === 'show';\n      })) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data);\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n          var delayedLeave;\n          var performLeave = function () {\n            delayedLeave();\n          };\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n  };\n\n  /*  */\n\n  // Provides transition support for list items.\n  // supports move transitions using the FLIP technique.\n\n  // Because the vdom's children update algorithm is \"unstable\" - i.e.\n  // it doesn't guarantee the relative positioning of removed elements,\n  // we force transition-group to update its children into two passes:\n  // in the first pass, we remove all nodes that need to be removed,\n  // triggering their leaving transition; in the second pass, we insert/move\n  // into the final desired state. This way in the second pass removed\n  // nodes will remain where they should be.\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n\n    beforeUpdate: function beforeUpdate() {\n      // force removing pass\n      this.__patch__(this._vnode, this.kept, false, // hydrating\n      true // removeOnly (!important avoids unnecessary moves)\n      );\n      this._vnode = this.kept;\n    },\n\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation);\n\n      // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n      this._reflow = document.body.offsetHeight;\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n        if (this._hasMove) {\n          return this._hasMove;\n        }\n        // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n        var clone = el.cloneNode();\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n\n  /*  */\n\n  // install platform specific utils\n  Vue$3.config.mustUseProp = mustUseProp;\n  Vue$3.config.isReservedTag = isReservedTag;\n  Vue$3.config.isReservedAttr = isReservedAttr;\n  Vue$3.config.getTagNamespace = getTagNamespace;\n  Vue$3.config.isUnknownElement = isUnknownElement;\n\n  // install platform runtime directives & components\n  extend(Vue$3.options.directives, platformDirectives);\n  extend(Vue$3.options.components, platformComponents);\n\n  // install platform patch function\n  Vue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n  // public mount method\n  Vue$3.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  Vue$3.nextTick(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue$3);\n      } else if (\"development\" !== 'production' && isChrome) {\n        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n      }\n    }\n    if (\"development\" !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {\n      console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n    }\n  }, 0);\n\n  /*  */\n\n  var defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return;\n    }\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n    while (match = tagRE.exec(text)) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      rawTokens.push({ '@binding': exp });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    };\n  }\n\n  /*  */\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (\"development\" !== 'production' && staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n      if (res) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n\n  /*  */\n\n  function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n        if (res) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n\n  /*  */\n\n  var decoder;\n\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n  };\n\n  /*  */\n\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  /*!\n   * HTML Parser By John Resig (ejohn.org)\n   * Modified by Juriy \"kangax\" Zaytsev\n   * Original code by Erik Arvidsson, Mozilla Public License\n   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n   */\n\n  // Regular Expressions for parsing tags and attributes\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n  // but for Vue templates we can enforce a simple charset\n  var ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp(\"^<\" + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n  var comment = /^<!--/;\n  var conditionalComment = /^<!\\[/;\n\n  var IS_REGEX_CAPTURING_BROKEN = false;\n  'x'.replace(/x(.)?/g, function (m, g) {\n    IS_REGEX_CAPTURING_BROKEN = g === '';\n  });\n\n  // Special Elements (can contain anything)\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t'\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\n\n  // #5992\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n  var shouldIgnoreFirstNewline = function (tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a plaintext content element like script/style\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd));\n              }\n              advance(commentEnd + 3);\n              continue;\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            if (shouldIgnoreFirstNewline(lastTag, html)) {\n              advance(1);\n            }\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n            if (next < 0) {\n              break;\n            }\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n          text = html.substring(0, textEnd);\n          advance(textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n          html = '';\n        }\n\n        if (options.chars && text) {\n          options.chars(text);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n          if (options.chars) {\n            options.chars(text);\n          }\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n        if (\"development\" !== 'production' && !stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n        }\n        break;\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n          advance(attr[0].length);\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n          if (args[3] === '') {\n            delete args[3];\n          }\n          if (args[4] === '') {\n            delete args[4];\n          }\n          if (args[5] === '') {\n            delete args[5];\n          }\n        }\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n      if (start == null) {\n        start = index;\n      }\n      if (end == null) {\n        end = index;\n      }\n\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n      }\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (\"development\" !== 'production' && (i > pos || !tagName) && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n          }\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^v-bind:/;\n  var modifierRE = /\\.[^.]+/g;\n\n  var decodeHTMLCached = cached(he.decode);\n\n  // configurable state\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n\n  function createASTElement(tag, attrs, parent) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      parent: parent,\n      children: []\n    };\n  }\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n    delimiters = options.delimiters;\n\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg);\n      }\n    }\n\n    function closeElement(element) {\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n      // apply post-transforms\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      start: function start(tag, attrs, unary) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n        if (ns) {\n          element.ns = ns;\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          \"development\" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n          // element-scope stuff\n          processElement(element, options);\n        }\n\n        function checkRootConstraints(el) {\n          {\n            if (el.tag === 'slot' || el.tag === 'template') {\n              warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n            }\n            if (el.attrsMap.hasOwnProperty('v-for')) {\n              warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n            }\n          }\n        }\n\n        // tree management\n        if (!root) {\n          root = element;\n          checkRootConstraints(root);\n        } else if (!stack.length) {\n          // allow root elements with v-if, v-else-if and v-else\n          if (root.if && (element.elseif || element.else)) {\n            checkRootConstraints(element);\n            addIfCondition(root, {\n              exp: element.elseif,\n              block: element\n            });\n          } else {\n            warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n          }\n        }\n        if (currentParent && !element.forbidden) {\n          if (element.elseif || element.else) {\n            processIfConditions(element, currentParent);\n          } else if (element.slotScope) {\n            // scoped slot\n            currentParent.plain = false;\n            var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          } else {\n            currentParent.children.push(element);\n            element.parent = currentParent;\n          }\n        }\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n\n      end: function end() {\n        // remove trailing whitespace\n        var element = stack[stack.length - 1];\n        var lastNode = element.children[element.children.length - 1];\n        if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n          element.children.pop();\n        }\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        closeElement(element);\n      },\n\n      chars: function chars(text) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.');\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n            }\n          }\n          return;\n        }\n        // IE textarea placeholder bug\n        /* istanbul ignore if */\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n        var children = currentParent.children;\n        text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n        if (text) {\n          var res;\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            children.push({\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            });\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            children.push({\n              type: 3,\n              text: text\n            });\n          }\n        }\n      },\n      comment: function comment(text) {\n        currentParent.children.push({\n          type: 3,\n          text: text,\n          isComment: true\n        });\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var l = el.attrsList.length;\n    if (l) {\n      var attrs = el.attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        attrs[i] = {\n          name: el.attrsList[i].name,\n          value: JSON.stringify(el.attrsList[i].value)\n        };\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement(element, options) {\n    processKey(element);\n\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain = !element.key && !element.attrsList.length;\n\n    processRef(element);\n    processSlot(element);\n    processComponent(element);\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      if (\"development\" !== 'production' && el.tag === 'template') {\n        warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var res = parseFor(exp);\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\"Invalid v-for expression: \" + exp);\n      }\n    }\n  }\n\n  function parseFor(exp) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      return;\n    }\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '');\n      res.iterator1 = iteratorMatch[1].trim();\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n    return res;\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (\"development\" !== 'production' && children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n        }\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  function processSlot(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n      if (\"development\" !== 'production' && el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n      }\n    } else {\n      var slotScope;\n      if (el.tag === 'template') {\n        slotScope = getAndRemoveAttr(el, 'scope');\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && slotScope) {\n          warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", true);\n        }\n        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n      } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && el.attrsMap['v-for']) {\n          warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", true);\n        }\n        el.slotScope = slotScope;\n      }\n      var slotTarget = getBindingAttr(el, 'slot');\n      if (slotTarget) {\n        el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n        // preserve slot as an attribute for native shadow DOM compat\n        // only for non-scoped slots.\n        if (el.tag !== 'template' && !el.slotScope) {\n          addAttr(el, 'slot', slotTarget);\n        }\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, isProp;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name);\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isProp = false;\n          if (modifiers) {\n            if (modifiers.prop) {\n              isProp = true;\n              name = camelize(name);\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n            if (modifiers.camel) {\n              name = camelize(name);\n            }\n            if (modifiers.sync) {\n              addHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n            }\n          }\n          if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, value);\n          } else {\n            addAttr(el, name, value);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          addHandler(el, name, value, modifiers, false, warn$2);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n          }\n          addDirective(el, name, rawName, value, arg, modifiers);\n          if (\"development\" !== 'production' && name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n          if (res) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n          }\n        }\n        addAttr(el, name, JSON.stringify(value));\n        // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true');\n        }\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true;\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\"development\" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map;\n  }\n\n  // for script (e.g. type=\"x/template\") or style, do not decode content\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug(attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n      }\n      _el = _el.parent;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Expand input[v-model] with dyanmic type bindings into v-if-else chains\n   * Turn this:\n   *   <input v-model=\"data[type]\" :type=\"type\">\n   * into this:\n   *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n   *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n   *   <input v-else :type=\"type\" v-model=\"data[type]\">\n   */\n\n  function preTransformNode(el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n      if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {\n        var typeBinding = getBindingAttr(el, 'type');\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n        // 1. checkbox\n        var branch0 = cloneASTElement(el);\n        // process for on the main node\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        });\n        // 2. add radio else-if condition\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        });\n        // 3. other\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0;\n      }\n    }\n  }\n\n  function cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n  }\n\n  var model$2 = {\n    preTransformNode: preTransformNode\n  };\n\n  var modules$1 = [klass$1, style$1, model$2];\n\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n    }\n  }\n\n  /*  */\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic$1(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      }\n      // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n      if (node.tag !== 'template') {\n        return false;\n      }\n      if (node.for) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /*  */\n\n  var fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n  var simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n  // keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n  var genGuard = function (condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative, warn) {\n    var res = isNative ? 'nativeOn:{' : 'on:{';\n    for (var name in events) {\n      res += \"\\\"\" + name + \"\\\":\" + genHandler(name, events[name]) + \",\";\n    }\n    return res.slice(0, -1) + '}';\n  }\n\n  function genHandler(name, handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(name, handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value;\n      }\n      /* istanbul ignore if */\n      return \"function($event){\" + handler.value + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key];\n          // left/right\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = handler.modifiers;\n          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n            return !modifiers[keyModifier];\n          }).map(function (keyModifier) {\n            return \"$event.\" + keyModifier + \"Key\";\n          }).join('||'));\n        } else {\n          keys.push(key);\n        }\n      }\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      }\n      // Make sure modifiers like prevent and stop get executed after key filtering\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n      var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? \"(\" + handler.value + \")($event)\" : handler.value;\n      /* istanbul ignore if */\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n    var code = keyCodes[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(code) + \",\" + \"$event.key)\";\n  }\n\n  /*  */\n\n  function on(el, dir) {\n    if (\"development\" !== 'production' && dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n\n  /*  */\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n\n  /*  */\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n\n  /*  */\n\n  var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n    this.maybeComponent = function (el) {\n      return !isReservedTag(el.tag);\n    };\n    this.onceId = 0;\n    this.staticRenderFns = [];\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data = el.plain ? undefined : genData$2(el, state);\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      }\n      // module transforms\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n      return code;\n    }\n  }\n\n  // hoist static sub-trees out\n  function genStatic(el, state) {\n    el.staticProcessed = true;\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  }\n\n  // v-once\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!key) {\n        \"development\" !== 'production' && state.warn(\"v-once can only be used inside v-for that is keyed. \");\n        return genElement(el, state);\n      }\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    }\n\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (\"development\" !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el, state);\n    if (dirs) {\n      data += dirs + ',';\n    }\n\n    // key\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    }\n    // ref\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    }\n    // pre\n    if (el.pre) {\n      data += \"pre:true,\";\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    }\n    // module data generation functions\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n      data += \"attrs:{\" + genProps(el.attrs) + \"},\";\n    }\n    // DOM props\n    if (el.props) {\n      data += \"domProps:{\" + genProps(el.props) + \"},\";\n    }\n    // event handlers\n    if (el.events) {\n      data += genHandlers(el.events, false, state.warn) + \",\";\n    }\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true, state.warn) + \",\";\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n      data += genScopedSlots(el.scopedSlots, state) + \",\";\n    }\n    // component v-model\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind data wrap\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n    if (!dirs) {\n      return;\n    }\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n    if (\"development\" !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {\n      state.warn('Inline-template components must have exactly one child element.');\n    }\n    if (ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(slots, state) {\n    return \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state);\n    }).join(',') + \"])\";\n  }\n\n  function genScopedSlot(key, el, state) {\n    if (el.for && !el.forProcessed) {\n      return genForScopedSlot(key, el, state);\n    }\n    var fn = \"function(\" + String(el.slotScope) + \"){\" + \"return \" + (el.tag === 'template' ? el.if ? el.if + \"?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\";\n    return \"{key:\" + key + \",fn:\" + fn + \"}\";\n  }\n\n  function genForScopedSlot(key, el, state) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n    el.forProcessed = true; // avoid recursion\n    return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el, state) + '})';\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n    if (children.length) {\n      var el$1 = children[0];\n      // optimize single v-for\n      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        return (altGenElement || genElement)(el$1, state);\n      }\n      var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n    }\n  }\n\n  // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n      if (el.type !== 1) {\n        continue;\n      }\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    }if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e(\" + JSON.stringify(comment.text) + \")\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n    var attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n      return camelize(a.name) + \":\" + a.value;\n    }).join(',') + \"}\";\n    var bind$$1 = el.attrsMap['v-bind'];\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n    return res + ')';\n  }\n\n  // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var res = '';\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      /* istanbul ignore if */\n      {\n        res += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n      }\n    }\n    return res.slice(0, -1);\n  }\n\n  // #3895, #4268\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n  }\n\n  /*  */\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n  // these unary operators should not be used as property/method names\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors(ast) {\n    var errors = [];\n    if (ast) {\n      checkNode(ast, errors);\n    }\n    return errors;\n  }\n\n  function checkNode(node, errors) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], errors);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, errors);\n    }\n  }\n\n  function checkEvent(exp, text, errors) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      errors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n    }\n    checkExpression(exp, text, errors);\n  }\n\n  function checkFor(node, text, errors) {\n    checkExpression(node.for || '', text, errors);\n    checkIdentifier(node.alias, 'v-for alias', text, errors);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n  }\n\n  function checkIdentifier(ident, type, text, errors) {\n    if (typeof ident === 'string') {\n      try {\n        new Function(\"var \" + ident + \"=_\");\n      } catch (e) {\n        errors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n      }\n    }\n  }\n\n  function checkExpression(exp, text, errors) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        errors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim());\n      } else {\n        errors.push(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\");\n      }\n    }\n  }\n\n  /*  */\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({ err: err, code: code });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n\n    return function compileToFunctions(template, options, vm) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n\n      /* istanbul ignore if */\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      }\n\n      // check cache\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n      if (cache[key]) {\n        return cache[key];\n      }\n\n      // compile\n      var compiled = compile(template, options);\n\n      // check compilation errors/tips\n      {\n        if (compiled.errors && compiled.errors.length) {\n          warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n            return \"- \" + e;\n          }).join('\\n') + '\\n', vm);\n        }\n        if (compiled.tips && compiled.tips.length) {\n          compiled.tips.forEach(function (msg) {\n            return tip(msg, vm);\n          });\n        }\n      }\n\n      // turn code into functions\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      });\n\n      // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n      /* istanbul ignore if */\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n\n      return cache[key] = res;\n    };\n  }\n\n  /*  */\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n        finalOptions.warn = function (msg, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          }\n          // merge custom directives\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n          }\n          // copy other options\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        var compiled = baseCompile(template, finalOptions);\n        {\n          errors.push.apply(errors, detectErrors(compiled.ast));\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n\n  /*  */\n\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compileToFunctions = ref$1.compileToFunctions;\n\n  /*  */\n\n  // check whether current browser encodes a char inside attribute values\n  var div;\n  function getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0;\n  }\n\n  // #3663: IE encodes newlines inside attribute values while other browsers don't\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n  // #6828: chrome encodes content in a[href]\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n\n  var mount = Vue$3.prototype.$mount;\n  Vue$3.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n      \"development\" !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n            if (\"development\" !== 'production' && !template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && config.performance && mark) {\n          mark('compile end');\n          measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n    return mount.call(this, el, hydrating);\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue$3.compile = compileToFunctions;\n\n  return Vue$3;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(5).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvdnVlLmpzPzQ1OTQiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZpbmUiLCJhbWQiLCJWdWUiLCJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiYmluZCIsImN0eCIsImJvdW5kRm4iLCJhIiwibCIsImFyZ3VtZW50cyIsImFwcGx5IiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheSIsImlzQXJyYXlCIiwiZXZlcnkiLCJlIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwicGF0aCIsInRlc3QiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwid2luZG93IiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiZXJyb3IiLCJpbmNsdWRlRmlsZSIsIiRyb290Iiwib3B0aW9ucyIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInB1c2giLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJkYXRhIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNoaWxkIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiZGVlcCIsImNsb25lZCIsImNsb25lVk5vZGVzIiwidm5vZGVzIiwibGVuIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYnNlcnZlclN0YXRlIiwic2hvdWxkQ29udmVydCIsIk9ic2VydmVyIiwidm1Db3VudCIsImF1Z21lbnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSIsIml0ZW1zIiwib2JzZXJ2ZSIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwicHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwibWF4IiwiZGVsIiwic3RyYXRzIiwiZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJ0eXBlIiwia2V5JDEiLCJwcm9wcyIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImhhbmRsZUVycm9yIiwiZXJyIiwiaW5mbyIsImN1ciIsImhvb2tzIiwiZXJyb3JDYXB0dXJlZCIsImNhcHR1cmUiLCJnbG9iYWxIYW5kbGVFcnJvciIsImxvZ0Vycm9yIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwibWljcm9UaW1lckZ1bmMiLCJtYWNyb1RpbWVyRnVuYyIsInVzZU1hY3JvVGFzayIsInNldEltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQiLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJzZXRUaW1lb3V0IiwiUHJvbWlzZSIsInAiLCJyZXNvbHZlIiwidGhlbiIsIndpdGhNYWNyb1Rhc2siLCJfd2l0aFRhc2siLCJuZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJtYXJrIiwibWVhc3VyZSIsInBlcmYiLCJjbGVhck1hcmtzIiwiY2xlYXJNZWFzdXJlcyIsInN0YXJ0VGFnIiwiZW5kVGFnIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5Iiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJvbGQiLCJldmVudCIsInBhcmFtcyIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwiaGFzaCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJsYXN0SW5kZXgiLCJzaGlmdCIsIl9pc1ZMaXN0IiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsInRvU3RyaW5nVGFnIiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJjb250ZXh0cyIsInN5bmMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlamVjdCIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsInRoaXMkMSIsImNicyIsImkkMSIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJuYW1lJDEiLCJpc1doaXRlc3BhY2UiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJhY3RpdmVJbnN0YW5jZSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsImluaXRMaWZlY3ljbGUiLCJhYnN0cmFjdCIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJoeWRyYXRpbmciLCJjYWxsSG9vayIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsIl92bm9kZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9wYXJlbnRFbG0iLCJfcmVmRWxtIiwiX192dWVfXyIsIiR2bm9kZSIsIiRkZXN0cm95IiwidGVhcmRvd24iLCJfd2F0Y2hlcnMiLCJfZGF0YSIsIm1vdW50Q29tcG9uZW50IiwidGVtcGxhdGUiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJfcmVuZGVyIiwiV2F0Y2hlciIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwicGFyZW50Vm5vZGUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0NoaWxkcmVuIiwiX3JlbmRlckNoaWxkcmVuIiwic2NvcGVkU2xvdHMiLCIkc2NvcGVkU2xvdHMiLCJfcGFyZW50Vm5vZGUiLCIkYXR0cnMiLCIkbGlzdGVuZXJzIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCIkc2xvdHMiLCJpc0luSW5hY3RpdmVUcmVlIiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRpcmVjdCIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImoiLCJNQVhfVVBEQVRFX0NPVU5UIiwicXVldWUiLCJhY3RpdmF0ZWRDaGlsZHJlbiIsImNpcmN1bGFyIiwid2FpdGluZyIsImZsdXNoaW5nIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwic29ydCIsInJ1biIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwiZW1pdCIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJjbGVhbnVwRGVwcyIsInRtcCIsIm9sZFZhbHVlIiwiZXZhbHVhdGUiLCJzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24iLCJwcm94eSIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwibG9vcCIsImh5cGhlbmF0ZWRLZXkiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsIiRkYXRhIiwic2hvdWxkQ2FjaGUiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNvbXB1dGVkR2V0dGVyIiwiaGFuZGxlciIsImNyZWF0ZVdhdGNoZXIiLCJrZXlPckZuIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIm5ld0RhdGEiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwiZmlsdGVyIiwicHJvdmlkZUtleSIsInNvdXJjZSIsInByb3ZpZGVEZWZhdWx0IiwicmVuZGVyTGlzdCIsInJlbmRlclNsb3QiLCJmYWxsYmFjayIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCJub2RlcyIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsIiRjcmVhdGVFbGVtZW50IiwicmVzb2x2ZUZpbHRlciIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluQWxpYXMiLCJldmVudEtleU5hbWUiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJpc1N5bmMiLCJkb21Qcm9wcyIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJfc3RhdGljVHJlZXMiLCJzdGF0aWNSZW5kZXJGbnMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsIm91cnMiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwiaW5qZWN0aW9ucyIsImNvbnRleHRWbSIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJpbml0IiwicGFyZW50RWxtIiwicmVmRWxtIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsIiRtb3VudCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJvbGRWbm9kZSIsImluc2VydCIsImRlc3Ryb3kiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJfYmFzZSIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwibWVyZ2VIb29rcyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwiZnJvbVBhcmVudCIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJmb3JjZSIsImluaXRSZW5kZXIiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZWYiLCJyZW5kZXJFcnJvciIsInVpZCQxIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsIlZ1ZSQzIiwiaW5pdFVzZSIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwiZ2V0Q29tcG9uZW50TmFtZSIsIm1hdGNoZXMiLCJwYXR0ZXJuIiwicHJ1bmVDYWNoZSIsImtlZXBBbGl2ZUluc3RhbmNlIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsImN1cnJlbnQiLCJjYWNoZWQkJDEiLCJwYXR0ZXJuVHlwZXMiLCJSZWdFeHAiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsIk51bWJlciIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJyZWYkMSIsInBhcnNlSW50IiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwidXRpbCIsImRlbGV0ZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImNsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiZG9jdW1lbnQiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInF1ZXJ5Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpc1Vua25vd25FbGVtZW50JCQxIiwiaW5WUHJlIiwic29tZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwibmVzdGVkIiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJ0cmltIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJhZGRQcm9wIiwicGxhaW4iLCJhZGRBdHRyIiwiYWRkUmF3QXR0ciIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiYWRkRGlyZWN0aXZlIiwiYXJnIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJyaWdodCIsIm1pZGRsZSIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsInJlbW92ZUZyb21NYXAiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwiY29kZSIsInZhbHVlJDEiLCJiaW5kaW5nIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib25jZUhhbmRsZXIiLCJyZW1vdmUkMiIsImFkZCQxIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc05vdEluRm9jdXNBbmREaXJ0eSIsImlzRGlydHlXaXRoTW9kaWZpZXJzIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsInN0eWxlIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsInMiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYmVmb3JlRW50ZXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJkaXJlY3RpdmUiLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsImdldFZhbHVlIiwib25Db21wb3NpdGlvbkVuZCIsIm9uQ29tcG9zaXRpb25TdGFydCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJoIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsImtlcHQiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYmVmb3JlVXBkYXRlIiwidXBkYXRlZCIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsIl9yZWZsb3ciLCJib2R5Iiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwib3BlbiIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwiZXhlYyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJwYXJzZUhUTUwiLCJzdGFjayIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJyZXN0JDEiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicGFyc2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJjbG9zZUVsZW1lbnQiLCJlbGVtZW50IiwiY29tbWVudHMiLCJndWFyZElFU1ZHQnVnIiwiaXNGb3JiaWRkZW5UYWciLCJmb3JiaWRkZW4iLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwicHJvY2Vzc0VsZW1lbnQiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwicHJlVHJhbnNmb3JtTm9kZSIsInR5cGVCaW5kaW5nIiwiaWZDb25kaXRpb24iLCJpZkNvbmRpdGlvbkV4dHJhIiwiaGFzRWxzZSIsImVsc2VJZkNvbmRpdGlvbiIsImJyYW5jaDAiLCJjbG9uZUFTVEVsZW1lbnQiLCJicmFuY2gxIiwiYnJhbmNoMiIsIm1vZGVsJDIiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJiYXNlT3B0aW9ucyIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwibCQxIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290IiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImRvd24iLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJtYXliZUNvbXBvbmVudCIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJnZW5TY29wZWRTbG90IiwiZ2VuRm9yU2NvcGVkU2xvdCIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJGdW5jdGlvbiIsIm1lc3NhZ2UiLCJjcmVhdGVGdW5jdGlvbiIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwid2FybiQkMSIsImNvbXBpbGVkIiwidGlwcyIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsImRpdiIsImdldFNob3VsZERlY29kZSIsImhyZWYiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImRvY3VtZW50RWxlbWVudCIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0MsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBMkI7QUFDeEIsVUFBK0RDLE9BQU9DLE9BQVAsR0FBaUJGLFNBQWhGLEdBQ0EsT0FBT0csTUFBUCxLQUFrQixVQUFsQixJQUFnQ0EsT0FBT0MsR0FBdkMsR0FBNkNELE9BQU9ILE9BQVAsQ0FBN0MsR0FDQ0QsT0FBT00sR0FBUCxHQUFhTCxTQUZkO0FBR0gsQ0FKQSxFQUlDLElBSkQsRUFJUSxZQUFZO0FBQUU7O0FBRXZCOztBQUVBLE1BQUlNLGNBQWNDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLENBQWxCOztBQUVBO0FBQ0E7QUFDQSxXQUFTQyxPQUFULENBQWtCQyxDQUFsQixFQUFxQjtBQUNuQixXQUFPQSxNQUFNQyxTQUFOLElBQW1CRCxNQUFNLElBQWhDO0FBQ0Q7O0FBRUQsV0FBU0UsS0FBVCxDQUFnQkYsQ0FBaEIsRUFBbUI7QUFDakIsV0FBT0EsTUFBTUMsU0FBTixJQUFt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O0FBQ0Y7QUFDRCxXQUFPb2dDLE1BQU14aEQsSUFBTixDQUFXLElBQVgsRUFBaUJvUyxFQUFqQixFQUFxQjZOLFNBQXJCLENBQVA7QUFDRCxHQWxFRDs7QUFvRUE7Ozs7QUFJQSxXQUFTeWhDLFlBQVQsQ0FBdUJ0dkMsRUFBdkIsRUFBMkI7QUFDekIsUUFBSUEsR0FBR3V2QyxTQUFQLEVBQWtCO0FBQ2hCLGFBQU92dkMsR0FBR3V2QyxTQUFWO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSUMsWUFBWWp1QixTQUFTM0ksYUFBVCxDQUF1QixLQUF2QixDQUFoQjtBQUNBNDJCLGdCQUFVOXNCLFdBQVYsQ0FBc0IxaUIsR0FBRzY4QixTQUFILENBQWEsSUFBYixDQUF0QjtBQUNBLGFBQU8yUyxVQUFVN25CLFNBQWpCO0FBQ0Q7QUFDRjs7QUFFRC9LLFFBQU0weEIsT0FBTixHQUFnQkMsa0JBQWhCOztBQUVBLFNBQU8zeEIsS0FBUDtBQUVDLENBeGlWQSxDQUFELEMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjUuMTNcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLlZ1ZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSBlLmcuIFtvYmplY3QgT2JqZWN0XVxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxue1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlLCBkZWVwKSB7XG4gIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIGNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgaWYgKGRlZXApIHtcbiAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGNsb25lZC5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKHZub2RlLmNoaWxkcmVuLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMgJiYgY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbikge1xuICAgICAgY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sIHRydWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMsIGRlZXApIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldLCBkZWVwKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWVcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpICtcbiAgICAgIFwiLCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHZtKSB7XG4gICAgdmFyIGN1ciA9IHZtO1xuICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgIGlmIChob29rcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE1lc3NhZ2VDaGFubmVsICovXG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIGJvdGggbWljcm8gYW5kIG1hY3JvIHRhc2tzLlxuLy8gSW4gPCAyLjQgd2UgdXNlZCBtaWNybyB0YXNrcyBldmVyeXdoZXJlLCBidXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zIHdoZXJlXG4vLyBtaWNybyB0YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmVzIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwKSBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWVcbi8vIGV2ZW50ICgjNjU2NikuIEhvd2V2ZXIsIHVzaW5nIG1hY3JvIHRhc2tzIGV2ZXJ5d2hlcmUgYWxzbyBoYXMgc3VidGxlIHByb2JsZW1zXG4vLyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnQgKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBIZXJlIHdlIHVzZSBtaWNybyB0YXNrIGJ5IGRlZmF1bHQsIGJ1dCBleHBvc2UgYSB3YXkgdG8gZm9yY2UgbWFjcm8gdGFzayB3aGVuXG4vLyBuZWVkZWQgKGUuZy4gaW4gZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgYnkgdi1vbikuXG52YXIgbWljcm9UaW1lckZ1bmM7XG52YXIgbWFjcm9UaW1lckZ1bmM7XG52YXIgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG5cbi8vIERldGVybWluZSAobWFjcm8pIFRhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vLyBUZWNobmljYWxseSBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIHRoZSBpZGVhbCBjaG9pY2UsIGJ1dCBpdCdzIG9ubHkgYXZhaWxhYmxlXG4vLyBpbiBJRS4gVGhlIG9ubHkgcG9seWZpbGwgdGhhdCBjb25zaXN0ZW50bHkgcXVldWVzIHRoZSBjYWxsYmFjayBhZnRlciBhbGwgRE9NXG4vLyBldmVudHMgdHJpZ2dlcmVkIGluIHRoZSBzYW1lIGxvb3AgaXMgYnkgdXNpbmcgTWVzc2FnZUNoYW5uZWwuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNZXNzYWdlQ2hhbm5lbCkgfHxcbiAgLy8gUGhhbnRvbUpTXG4gIE1lc3NhZ2VDaGFubmVsLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE1lc3NhZ2VDaGFubmVsQ29uc3RydWN0b3JdJ1xuKSkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2hDYWxsYmFja3M7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UoMSk7XG4gIH07XG59IGVsc2Uge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuLy8gRGV0ZXJtaW5lIE1pY3JvVGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgbWljcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBmYWxsYmFjayB0byBtYWNyb1xuICBtaWNyb1RpbWVyRnVuYyA9IG1hY3JvVGltZXJGdW5jO1xufVxuXG4vKipcbiAqIFdyYXAgYSBmdW5jdGlvbiBzbyB0aGF0IGlmIGFueSBjb2RlIGluc2lkZSB0cmlnZ2VycyBzdGF0ZSBjaGFuZ2UsXG4gKiB0aGUgY2hhbmdlcyBhcmUgcXVldWVkIHVzaW5nIGEgVGFzayBpbnN0ZWFkIG9mIGEgTWljcm9UYXNrLlxuICovXG5mdW5jdGlvbiB3aXRoTWFjcm9UYXNrIChmbikge1xuICByZXR1cm4gZm4uX3dpdGhUYXNrIHx8IChmbi5fd2l0aFRhc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXNlTWFjcm9UYXNrID0gdHJ1ZTtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgaWYgKHVzZU1hY3JvVGFzaykge1xuICAgICAgbWFjcm9UaW1lckZ1bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWljcm9UaW1lckZ1bmMoKTtcbiAgICB9XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxue1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxue1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCBudWxsLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSAocGFyZW50Vm5vZGUuZGF0YSAmJiBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzKSB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IHVzZXJEZWY7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBrZXlPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChrZXlPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcbiAgICAgIH0pXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICB2YXIgbm9kZXM7XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2Rlcykge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhcyxcbiAgZXZlbnRLZXlOYW1lXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoa2V5Q29kZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gICAgfVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCk7IH07XG5cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IGRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gICAgdm5vZGUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cblxuLy8gUmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBob29rIHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG4vLyBUaGUgaG9vayB3aWxsIGJlIHRyaWdnZXJlZCBieSBuYXRpdmUsIG5vdCBqYXZhc2NyaXB0LlxuXG5cbi8vIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cblxuLyogICovXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcblxuLy8gbGlzdGVuaW5nIG9uIG5hdGl2ZSBjYWxsYmFja1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgLy8gV2VleCBzcGVjaWZpYzogaW52b2tlIHJlY3ljbGUtbGlzdCBvcHRpbWl6ZWQgQHJlbmRlciBmdW5jdGlvbiBmb3JcbiAgLy8gZXh0cmFjdGluZyBjZWxsLXNsb3QgdGVtcGxhdGUuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoaXNVbmRlZihjaGlsZC5ucykgfHwgaXNUcnVlKGZvcmNlKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGlmIHRoZSBwYXJlbnQgZGlkbid0IHVwZGF0ZSwgdGhlIHNsb3Qgbm9kZXMgd2lsbCBiZSB0aGUgb25lcyBmcm9tXG4gICAgICAvLyBsYXN0IHJlbmRlci4gVGhleSBuZWVkIHRvIGJlIGNsb25lZCB0byBlbnN1cmUgXCJmcmVzaG5lc3NcIiBmb3IgdGhpcyByZW5kZXIuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIHZhciBzbG90ID0gdm0uJHNsb3RzW2tleV07XG4gICAgICAgIC8vIF9yZW5kZXJlZCBpcyBhIGZsYWcgYWRkZWQgYnkgcmVuZGVyU2xvdCwgYnV0IG1heSBub3QgYmUgcHJlc2VudFxuICAgICAgICAvLyBpZiB0aGUgc2xvdCBpcyBwYXNzZWQgZnJvbSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbnNcbiAgICAgICAgaWYgKHNsb3QuX3JlbmRlcmVkIHx8IChzbG90WzBdICYmIHNsb3RbMF0uZWxtKSkge1xuICAgICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXMoc2xvdCwgdHJ1ZSAvKiBkZWVwICovKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZtLiRzY29wZWRTbG90cyA9IChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQxKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMylcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGUsIGtleSwgdGhpcyQxLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuNS4xMyc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICAgIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICAgIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICAgIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICAgIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gICAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gICAgc2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxuICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgICAgLy8gaW1tZWRpYXRlbHkuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChcbiAgICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcbiAgICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgIWVsLl9faWVwaFxuICAgICAgKSB7XG4gICAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAgIH07XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgICB9XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGVsLmF0dHJzTWFwW25hbWVdID0gdmFsdWU7XG4gIGVsLmF0dHJzTGlzdC5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnQsXG4gIHdhcm5cbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXG4gIH1cblxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgLy8gdGhpcyBpcyB0ZWNobmljYWxseSBicm93c2VyLXNwZWNpZmljLCBidXQgYXQgbGVhc3QgZm9yIG5vdyBicm93c2VycyBhcmVcbiAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSB9O1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgIGtleTogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHZhbDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAge1xuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoWyQkdl0pKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAge1xuICAgIHZhciB2YWx1ZSQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICBpZiAodmFsdWUkMSkge1xuICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaGFuZGxlciA9IHdpdGhNYWNyb1Rhc2soaGFuZGxlcik7XG4gIGlmIChvbmNlJCQxKSB7IGhhbmRsZXIgPSBjcmVhdGVPbmNlSGFuZGxlcihoYW5kbGVyLCBldmVudCwgY2FwdHVyZSk7IH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLl93aXRoVGFzayB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubGF6eSkge1xuICAgICAgLy8gaW5wdXRzIHdpdGggbGF6eSBzaG91bGQgb25seSBiZSB1cGRhdGVkIHdoZW4gbm90IGluIGZvY3VzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZik7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZilcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50IGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5WdWUkMy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgKTtcbiAgfVxufSwgMCk7XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cblxuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHJhd1Rva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKTtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHByZXNzaW9uOiB0b2tlbnMuam9pbignKycpLFxuICAgIHRva2VuczogcmF3VG9rZW5zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/Lztcbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCdcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgLy8gZWxlbWVudC1zY29wZSBzdHVmZlxuICAgICAgICBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxuICAgICAgICA/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XG4gICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiAzLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoO1xuXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgaWYgKCFpbk1hdGNoKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90U2NvcGU7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBzbG90U2NvcGUpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcbiAgICAgICAgICBcInJlcGxhY2VkIGJ5IFxcXCJzbG90LXNjb3BlXFxcIiBzaW5jZSAyLjUuIFRoZSBuZXcgXFxcInNsb3Qtc2NvcGVcXFwiIGF0dHJpYnV0ZSBcIiArXG4gICAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xuICAgICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcbiAgICAgICAgICBcIih2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBcIiArXG4gICAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgIH1cbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgICAgaWYgKGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIHtcbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEV4cGFuZCBpbnB1dFt2LW1vZGVsXSB3aXRoIGR5YW5taWMgdHlwZSBiaW5kaW5ncyBpbnRvIHYtaWYtZWxzZSBjaGFpbnNcbiAqIFR1cm4gdGhpczpcbiAqICAgPGlucHV0IHYtbW9kZWw9XCJkYXRhW3R5cGVdXCIgOnR5cGU9XCJ0eXBlXCI+XG4gKiBpbnRvIHRoaXM6XG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UtaWY9XCJ0eXBlID09PSAncmFkaW8nXCIgdHlwZT1cInJhZGlvXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZSA6dHlwZT1cInR5cGVcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICovXG5cbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICB2YXIgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKG1hcFsndi1tb2RlbCddICYmIChtYXBbJ3YtYmluZDp0eXBlJ10gfHwgbWFwWyc6dHlwZSddKSkge1xuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDIgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDJcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZSxcbiAgd2FyblxuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgZXZlbnRzW25hbWVdKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAoXCIkZXZlbnQuXCIgKyBrZXlNb2RpZmllciArIFwiS2V5XCIpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBjb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGNvZGUpKSArIFwiLFwiICtcbiAgICBcIiRldmVudC5rZXkpXCJcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICBzdGF0ZS53YXJuKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSwgc3RhdGUpXG4gICAgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpXG4gIH1cbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuc2xvdFNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZlxuICAgICAgICA/ICgoZWwuaWYpICsgXCI/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIjtcbiAgcmV0dXJuIChcIntrZXk6XCIgKyBrZXkgKyBcIixmbjpcIiArIGZuICsgXCJ9XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZvclNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGdlblNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgcmV0dXJuIChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICB9IGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgZXJyb3JzXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XG4gICAgICB7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbnJldHVybiBWdWUkMztcblxufSkpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy92dWUuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(6);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz9kN2FkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(7)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz85YjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzViNjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ })
/******/ ]);
